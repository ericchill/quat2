// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "ObjectEditor.h"
// Quat - A 3D fractal generation program
// Copyright (C) 1997-2000 Dirk Meyer
// (email: dirk.meyer@studserv.uni-stuttgart.de)
// mail:  Dirk Meyer
//        Marbacher Weg 29
//        D-71334 Waiblingen
//        Germany
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

#include <cmath> // fabs
#include "ChildWindow.h"
#define VD(a) (a)->value()
#define VI(a) static_cast<int>((a)->value())
#include "MandelPreview.h"

void ObjectEditor::cb_maxiter_i(Fl_Value_Input* o, void*) {
  MP->maxiter(VI(o));
frac._maxiter = VI(o);
o->color(FL_WHITE);
if (VI(o)<=0) o->color(FL_RED);
if (VI(o)>65535) o->color(FL_RED);
o->redraw();
}
void ObjectEditor::cb_maxiter(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_maxiter_i(o,v);
}

void ObjectEditor::cb_lvalue_i(Fl_Value_Input* o, void*) {
  frac._lTerm = VD(o);
o->color(FL_WHITE);
if (fabs(VD(o))>2.0) o->color(FL_YELLOW);
if (fabs(VD(o))>=1000000.0) o->color(FL_RED);
o->redraw();
}
void ObjectEditor::cb_lvalue(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_lvalue_i(o,v);
}

void ObjectEditor::cb_bailout_i(Fl_Value_Input* o, void*) {
  MP->bailout(VD(o));
frac._bailout = VD(o);
o->color(FL_WHITE);
if (VD(o) <= 0.0 || VD(o) >= 1E20) o->color(FL_RED);
else if (VD(o) < 4.0) o->color(FL_YELLOW);
else o->color(FL_WHITE);
o->redraw();
}
void ObjectEditor::cb_bailout(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_bailout_i(o,v);
}

void ObjectEditor::cb_formula_i(Fl_Choice* o, void*) {
  MP->formula(VI(o));
frac._formula = VI(o);
formula_changed();
}
void ObjectEditor::cb_formula(Fl_Choice* o, void* v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_formula_i(o,v);
}

Fl_Menu_Item ObjectEditor::menu_formula[] = {
 {"Classical Julia", 0x61,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Lambda Julia", 0x62,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"x[n+1] = x[n]*ln(x[n]) - c", 0x63,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"Cubic Julia", 0x64,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"x[n+1] = x[n]^p1-c", 0x65,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {"z^2+c Mandelbulb", 0x66,  0, 0, 0, (uchar)FL_NORMAL_LABEL, 0, 12, 0},
 {0,0,0,0,0,0,0,0,0}
};

void ObjectEditor::cb_cre_i(Fl_Value_Input* o, void*) {
  MP->SetCX(VD(o));
frac._c[0] = VD(o);
}
void ObjectEditor::cb_cre(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_cre_i(o,v);
}

void ObjectEditor::cb_ci_i(Fl_Value_Input* o, void*) {
  MP->SetCY(VD(o));
frac._c[1] = VD(o);
}
void ObjectEditor::cb_ci(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_ci_i(o,v);
}

void ObjectEditor::cb_cj_i(Fl_Value_Input* o, void*) {
  MP->cj(VD(o));
frac._c[2] = VD(o);
}
void ObjectEditor::cb_cj(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_cj_i(o,v);
}

void ObjectEditor::cb_ck_i(Fl_Value_Input* o, void*) {
  MP->ck(VD(o));
frac._c[3] = VD(o);
}
void ObjectEditor::cb_ck(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_ck_i(o,v);
}

void ObjectEditor::cb_up_i(Fl_Button*, void*) {
  MP->MoveUp();
}
void ObjectEditor::cb_up(Fl_Button* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb_up_i(o,v);
}

void ObjectEditor::cb__i(Fl_Button*, void*) {
  MP->MoveLeft();
}
void ObjectEditor::cb_(Fl_Button* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb__i(o,v);
}

void ObjectEditor::cb_1_i(Fl_Button*, void*) {
  MP->ZoomIn();
}
void ObjectEditor::cb_1(Fl_Button* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb_1_i(o,v);
}

void ObjectEditor::cb_2_i(Fl_Button*, void*) {
  MP->ZoomOut();
}
void ObjectEditor::cb_2(Fl_Button* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb_2_i(o,v);
}

void ObjectEditor::cb_3_i(Fl_Button*, void*) {
  MP->MoveRight();
}
void ObjectEditor::cb_3(Fl_Button* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb_3_i(o,v);
}

void ObjectEditor::cb_down_i(Fl_Button*, void*) {
  MP->MoveDown();
}
void ObjectEditor::cb_down(Fl_Button* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb_down_i(o,v);
}

void ObjectEditor::cb_redraw_i(Fl_Button*, void*) {
  MP->CalcImage();
MP->redraw();
MP->CheckUpdate();
}
void ObjectEditor::cb_redraw(Fl_Button* o, void* v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_redraw_i(o,v);
}

void ObjectEditor::cb_p_re_i(Fl_Value_Input* o, void*) {
  MP->p(paramscroll->value()-1, 0, VD(o));
frac._p[paramscroll->value()-1][0] = VD(o);
//cout << paramscroll->value() << endl;
}
void ObjectEditor::cb_p_re(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb_p_re_i(o,v);
}

void ObjectEditor::cb_p_i_i(Fl_Value_Input* o, void*) {
  MP->p(paramscroll->value()-1, 1, VD(o));
frac._p[paramscroll->value()-1][1] = VD(o);
}
void ObjectEditor::cb_p_i(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb_p_i_i(o,v);
}

void ObjectEditor::cb_p_j_i(Fl_Value_Input* o, void*) {
  MP->p(paramscroll->value()-1, 2, VD(o));
frac._p[paramscroll->value()-1][2] = VD(o);
}
void ObjectEditor::cb_p_j(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb_p_j_i(o,v);
}

void ObjectEditor::cb_p_k_i(Fl_Value_Input* o, void*) {
  MP->p(paramscroll->value()-1, 3, VD(o));
frac._p[paramscroll->value()-1][3] = VD(o);
}
void ObjectEditor::cb_p_k(Fl_Value_Input* o, void* v) {
  ((ObjectEditor*)(o->parent()->parent()->user_data()))->cb_p_k_i(o,v);
}

void ObjectEditor::cb_maxOrbit_i(Fl_Value_Input* o, long) {
  frac._maxOrbit = VI(o);
o->color(FL_WHITE);
if (VI(o)<=0) o->color(FL_RED);
if (VI(o)>10000) o->color(FL_RED);
o->redraw();
}
void ObjectEditor::cb_maxOrbit(Fl_Value_Input* o, long v) {
  ((ObjectEditor*)(o->parent()->user_data()))->cb_maxOrbit_i(o,v);
}

ObjectEditor::ObjectEditor(int X, int Y, int W, int H, const char *label) : Fl_Group(X, Y, W, H, label) {
  { win = new ChildWindow(415, 215);
    win->box(FL_FLAT_BOX);
    win->color(FL_BACKGROUND_COLOR);
    win->selection_color(FL_BACKGROUND_COLOR);
    win->labeltype(FL_NO_LABEL);
    win->labelfont(0);
    win->labelsize(14);
    win->labelcolor(FL_FOREGROUND_COLOR);
    win->user_data((void*)(this));
    win->align(Fl_Align(FL_ALIGN_TOP));
    win->when(FL_WHEN_RELEASE);
    { maxiter = new Fl_Value_Input(10, 35, 60, 20, "Max.\nIteration");
      maxiter->tooltip("Highest number of iterations done.");
      maxiter->labelsize(12);
      maxiter->minimum(1);
      maxiter->maximum(1e+20);
      maxiter->step(1);
      maxiter->textsize(12);
      maxiter->callback((Fl_Callback*)cb_maxiter);
      maxiter->align(Fl_Align(FL_ALIGN_TOP_LEFT));
    } // Fl_Value_Input* maxiter
    { lvalue = new Fl_Value_Input(75, 35, 95, 20, "4th-dim.\nIntersection");
      lvalue->tooltip("The constant value for the 4th part of a quaternion.");
      lvalue->labelsize(12);
      lvalue->minimum(-1e+20);
      lvalue->maximum(1e+20);
      lvalue->textsize(12);
      lvalue->callback((Fl_Callback*)cb_lvalue);
      lvalue->align(Fl_Align(FL_ALIGN_TOP_LEFT));
    } // Fl_Value_Input* lvalue
    { bailout = new Fl_Value_Input(175, 35, 95, 20, "Bailout");
      bailout->tooltip("If this value is exceeded, iteration is ready.");
      bailout->labelsize(12);
      bailout->maximum(1e+20);
      bailout->textsize(12);
      bailout->callback((Fl_Callback*)cb_bailout);
      bailout->align(Fl_Align(FL_ALIGN_TOP_LEFT));
    } // Fl_Value_Input* bailout
    { formula = new Fl_Choice(65, 65, 205, 30, "Iteration  \nFormula  ");
      formula->tooltip("The formula that gets iterated.");
      formula->down_box(FL_BORDER_BOX);
      formula->labelsize(12);
      formula->textsize(12);
      formula->callback((Fl_Callback*)cb_formula);
      formula->menu(menu_formula);
    } // Fl_Choice* formula
    { cre = new Fl_Value_Input(10, 125, 95, 20, "c (1, i, j, k parts)");
      cre->tooltip("Real part of c.");
      cre->labelsize(12);
      cre->minimum(-1e+20);
      cre->maximum(1e+20);
      cre->textsize(12);
      cre->callback((Fl_Callback*)cb_cre);
      cre->align(Fl_Align(FL_ALIGN_TOP_LEFT));
    } // Fl_Value_Input* cre
    { ci = new Fl_Value_Input(10, 145, 95, 20, "value:");
      ci->tooltip("1st imaginary (i) part of c.");
      ci->labeltype(FL_NO_LABEL);
      ci->labelsize(12);
      ci->minimum(-1e+20);
      ci->maximum(1e+20);
      ci->textsize(12);
      ci->callback((Fl_Callback*)cb_ci);
    } // Fl_Value_Input* ci
    { cj = new Fl_Value_Input(10, 165, 95, 20, "value:");
      cj->tooltip("2nd imaginary (j) part of c.");
      cj->labeltype(FL_NO_LABEL);
      cj->labelsize(12);
      cj->minimum(-1e+20);
      cj->maximum(1e+20);
      cj->textsize(12);
      cj->callback((Fl_Callback*)cb_cj);
    } // Fl_Value_Input* cj
    { ck = new Fl_Value_Input(10, 185, 95, 19, "value:");
      ck->tooltip("3rd imaginary part (k) of c.");
      ck->labeltype(FL_NO_LABEL);
      ck->labelsize(12);
      ck->minimum(-1e+20);
      ck->maximum(1e+20);
      ck->textsize(12);
      ck->callback((Fl_Callback*)cb_ck);
    } // Fl_Value_Input* ck
    { paramgroup = new Fl_Group(280, 20, 115, 125);
      { Fl_Box* o = new Fl_Box(285, 20, 105, 125, "Parameter");
        o->box(FL_UP_BOX);
        o->labelsize(12);
        o->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
      } // Fl_Box* o
      { paramscroll = new Fl_Scrollbar(290, 120, 95, 15);
        paramscroll->type(1);
      } // Fl_Scrollbar* paramscroll
      paramgroup->end();
    } // Fl_Group* paramgroup
    { Fl_Group* o = new Fl_Group(225, 165, 80, 40);
      { Fl_Button* o = new Fl_Button(225, 165, 40, 20, "up");
        o->tooltip("Navigation in Mandelbrot Preview.");
        o->shortcut(0x80069);
        o->labelsize(12);
        o->callback((Fl_Callback*)cb_up);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(225, 185, 20, 20, "<");
        o->tooltip("Navigation in Mandelbrot Preview: to the left.");
        o->shortcut(0x8006a);
        o->labelsize(12);
        o->callback((Fl_Callback*)cb_);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(245, 185, 20, 20, "+");
        o->tooltip("Zoom In.");
        o->shortcut(0x2b);
        o->labelsize(12);
        o->callback((Fl_Callback*)cb_1);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(265, 185, 20, 20, "-");
        o->tooltip("Zoom out.");
        o->shortcut(0x2d);
        o->labelsize(12);
        o->callback((Fl_Callback*)cb_2);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(285, 185, 20, 20, ">");
        o->tooltip("Navigation in Mandelbrot Preview: to the right.");
        o->shortcut(0x8006c);
        o->labelsize(12);
        o->callback((Fl_Callback*)cb_3);
      } // Fl_Button* o
      { Fl_Button* o = new Fl_Button(265, 165, 40, 20, "down");
        o->tooltip("Navigation in Mandelbrot Preview.");
        o->shortcut(0x8006b);
        o->labelsize(12);
        o->callback((Fl_Callback*)cb_down);
      } // Fl_Button* o
      o->end();
    } // Fl_Group* o
    { redraw = new Fl_Button(225, 125, 45, 20, "&redraw");
      redraw->tooltip("Redraws the Mandebrot Preview.");
      redraw->shortcut(0x80072);
      redraw->labelsize(12);
      redraw->callback((Fl_Callback*)cb_redraw);
      redraw->deactivate();
    } // Fl_Button* redraw
    { MP = new MandelPreview(110, 125, 110, 80, "label");
      MP->tooltip("Mandelbrot preview:\nfor easy selection of c (real- and i- part)\nRed frame: \
Redraw required.");
      MP->box(FL_EMBOSSED_FRAME);
      MP->color(FL_BACKGROUND_COLOR);
      MP->selection_color(FL_BACKGROUND_COLOR);
      MP->labeltype(FL_NO_LABEL);
      MP->labelfont(0);
      MP->labelsize(12);
      MP->labelcolor(FL_FOREGROUND_COLOR);
      MP->align(Fl_Align(FL_ALIGN_CENTER));
      MP->when(FL_WHEN_RELEASE);
    } // MandelPreview* MP
    { paramgroup2 = new Fl_Group(290, 20, 95, 100);
      { p_re = new Fl_Value_Input(290, 35, 95, 20, "p1");
        p_re->tooltip("Real part of p1.");
        p_re->labelsize(12);
        p_re->minimum(-1e+20);
        p_re->maximum(1e+20);
        p_re->textsize(12);
        p_re->callback((Fl_Callback*)cb_p_re);
        p_re->align(Fl_Align(FL_ALIGN_TOP_RIGHT));
      } // Fl_Value_Input* p_re
      { p_i = new Fl_Value_Input(290, 56, 95, 20, "value:");
        p_i->tooltip("1st imaginary (i) part of p1.");
        p_i->labeltype(FL_NO_LABEL);
        p_i->labelsize(12);
        p_i->minimum(-1e+20);
        p_i->maximum(1e+20);
        p_i->textsize(12);
        p_i->callback((Fl_Callback*)cb_p_i);
      } // Fl_Value_Input* p_i
      { p_j = new Fl_Value_Input(290, 76, 95, 20, "value:");
        p_j->tooltip("2nd imaginary (j) part of p1.");
        p_j->labeltype(FL_NO_LABEL);
        p_j->labelsize(12);
        p_j->minimum(-1e+20);
        p_j->maximum(1e+20);
        p_j->textsize(12);
        p_j->callback((Fl_Callback*)cb_p_j);
      } // Fl_Value_Input* p_j
      { p_k = new Fl_Value_Input(290, 96, 95, 19, "value:");
        p_k->tooltip("3rd imaginary (k) part of p1.");
        p_k->labeltype(FL_NO_LABEL);
        p_k->labelsize(12);
        p_k->minimum(-1e+20);
        p_k->maximum(1e+20);
        p_k->textsize(12);
        p_k->callback((Fl_Callback*)cb_p_k);
      } // Fl_Value_Input* p_k
      paramgroup2->end();
    } // Fl_Group* paramgroup2
    { maxOrbit = new Fl_Value_Input(320, 180, 70, 25, "Max. Orbit");
      maxOrbit->maximum(10000);
      maxOrbit->value(100);
      maxOrbit->callback((Fl_Callback*)cb_maxOrbit);
      maxOrbit->align(Fl_Align(FL_ALIGN_TOP));
    } // Fl_Value_Input* maxOrbit
    win->clear_border();
    win->end();
  } // ChildWindow* win
  MP->SetInputs(cre, ci, redraw);
  end(); // VERY IMPORTANT!
  win->position(X+2, Y+2);
  // DON'T delete win in destructor (or elsewhere) 
  // it's automatically deleted by Fl_Group
}

void ObjectEditor::set(const FractalSpec& f) {
  frac = f;
  maxiter->value(f._maxiter); maxiter->do_callback();
  lvalue->value(f._lTerm); lvalue->do_callback();
  bailout->value(f._bailout); bailout->do_callback();
  formula->value(f._formula); formula->do_callback(); // Also calls formula_changed()
  cre->value(f._c[0]); cre->do_callback();
  ci->value(f._c[1]); ci->do_callback();
  cj->value(f._c[2]); cj->do_callback();
  ck->value(f._c[3]); ck->do_callback();
  for (int j=0; j<4; j++) for (int i=0; i<4; i++) MP->p(j, i, f._p[j][i]);
  MP->CalcImage(); MP->CheckUpdate();
}

void ObjectEditor::get(FractalSpec& f) {
  f = frac;
}

void ObjectEditor::formula_changed() {
  int pno = 0;
  switch (frac._formula) {
  	case 4: pno = 1; break;
  	default: pno = 0; break;
  }
  
  if (pno == 0) { 
  	paramgroup->hide();
  	paramgroup2->hide();
  } else {
  	paramgroup->show();
  	paramgroup2->show();
  }
  
  paramscroll->scrollvalue(1,1,1,pno);
  if (pno != 0) {
  	paramscroll_changed();
  }
}

void ObjectEditor::paramscroll_changed() {
  int i = paramscroll->value();
  p_re->value(frac._p[i-1][0]);
  p_i->value(frac._p[i-1][1]);
  p_j->value(frac._p[i-1][2]);
  p_k->value(frac._p[i-1][3]);
}

void ObjectEditor::deactiv() {
  maxiter->deactivate();
  lvalue->deactivate();
  bailout->deactivate();
  formula->deactivate();
  cre->deactivate();
  ci->deactivate();
  cj->deactivate();
  ck->deactivate();
  MP->deactivate();
  paramgroup2->deactivate();
}
