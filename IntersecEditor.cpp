// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "IntersecEditor.h"
// Quat - A 3D fractal generation program
// Copyright (C) 1997-2000 Dirk Meyer
// (email: dirk.meyer@studserv.uni-stuttgart.de)
// mail:  Dirk Meyer
//        Marbacher Weg 29
//        D-71334 Waiblingen
//        Germany
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#include "ChildWindow.h"

void IntersecEditor::cb_scroll_i(Fl_Scrollbar* o, void*) {
  setIndex(o->value());
}
void IntersecEditor::cb_scroll(Fl_Scrollbar* o, void* v) {
  ((IntersecEditor*)(o->parent()->user_data()))->cb_scroll_i(o,v);
}

void IntersecEditor::cb_nre_i(Fl_Value_Input* o, void*) {
  _curNormal[0] = o->value();
_cuts.setPlane(_idx, _curNormal, _curPoint);
checkValidity();
}
void IntersecEditor::cb_nre(Fl_Value_Input* o, void* v) {
  ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_nre_i(o,v);
}

void IntersecEditor::cb_ni_i(Fl_Value_Input* o, void*) {
  _curNormal[1] = o->value();
_cuts.setPlane(_idx, _curNormal, _curPoint);
checkValidity();
}
void IntersecEditor::cb_ni(Fl_Value_Input* o, void* v) {
  ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_ni_i(o,v);
}

void IntersecEditor::cb_nj_i(Fl_Value_Input* o, void*) {
  _curNormal[2] = o->value();
_cuts.setPlane(_idx, _curNormal, _curPoint);
checkValidity();
}
void IntersecEditor::cb_nj(Fl_Value_Input* o, void* v) {
  ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_nj_i(o,v);
}

void IntersecEditor::cb_pre_i(Fl_Value_Input* o, void*) {
  _curPoint[0] = o->value();
            _cuts.setPlane(_idx, _curNormal, _curPoint);
}
void IntersecEditor::cb_pre(Fl_Value_Input* o, void* v) {
  ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_pre_i(o,v);
}

void IntersecEditor::cb_pi_i(Fl_Value_Input* o, void*) {
  _curPoint[1] = o->value();
            _cuts.setPlane(_idx, _curNormal, _curPoint);
}
void IntersecEditor::cb_pi(Fl_Value_Input* o, void* v) {
  ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_pi_i(o,v);
}

void IntersecEditor::cb_pj_i(Fl_Value_Input* o, void*) {
  _curPoint[2] = o->value();
            _cuts.setPlane(_idx, _curNormal, _curPoint);
}
void IntersecEditor::cb_pj(Fl_Value_Input* o, void* v) {
  ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_pj_i(o,v);
}

void IntersecEditor::cb_add_i(Fl_Button*, void*) {
  _cuts.addPlane(_curNormal, _curPoint);
//scroll->value(_cuts.count() - 1, _cuts.count(), 0, _cuts.count());
setIndex(_cuts.count() - 1);
}
void IntersecEditor::cb_add(Fl_Button* o, void* v) {
  ((IntersecEditor*)(o->parent()->user_data()))->cb_add_i(o,v);
}

void IntersecEditor::cb_del_i(Fl_Button*, void*) {
  _cuts.deletePlane(_idx);
if (_idx >= _cuts.count() && _idx != 0) {
    _idx = _cuts.count() - 1;
}
//scroll->value(_idx, _cuts.count(), 0, _cuts.count());
setIndex(_idx);
}
void IntersecEditor::cb_del(Fl_Button* o, void* v) {
  ((IntersecEditor*)(o->parent()->user_data()))->cb_del_i(o,v);
}

void IntersecEditor::cb_To_i(Fl_Button*, void*) {
  _curNormal = (_view._s - _curPoint).normalized();
_cuts.setPlane(_idx, _curNormal, _curPoint);
showVectors();
checkValidity();
}
void IntersecEditor::cb_To(Fl_Button* o, void* v) {
  ((IntersecEditor*)(o->parent()->user_data()))->cb_To_i(o,v);
}

IntersecEditor::IntersecEditor(int X, int Y, int W, int H, const char *label) : Fl_Group(X,Y,W,H,label), _idx(0), _disabled(false) {
  { win = new ChildWindow(415, 215);
    win->box(FL_FLAT_BOX);
    win->color(FL_BACKGROUND_COLOR);
    win->selection_color(FL_BACKGROUND_COLOR);
    win->labeltype(FL_NO_LABEL);
    win->labelfont(0);
    win->labelsize(14);
    win->labelcolor(FL_FOREGROUND_COLOR);
    win->user_data((void*)(this));
    win->align(Fl_Align(FL_ALIGN_TOP));
    win->when(FL_WHEN_RELEASE);
    { scroll = new Fl_Scrollbar(10, 20, 20, 150, "Plane to edit");
      scroll->tooltip("Select the intersection plane to edit.");
      scroll->labelsize(12);
      scroll->callback((Fl_Callback*)cb_scroll);
      scroll->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      scroll->linesize(1);
            scroll->value(0, 1, 0, 0);
    } // Fl_Scrollbar* scroll
    { qspacebox = new Fl_Group(120, 5, 270, 115, "QSpace coordinates");
      qspacebox->tooltip("All parameters in this box are measured in QSpace coordinates.");
      qspacebox->box(FL_EMBOSSED_BOX);
      qspacebox->labelsize(12);
      qspacebox->align(Fl_Align(FL_ALIGN_TOP_LEFT|FL_ALIGN_INSIDE));
      qspacebox->end();
    } // Fl_Group* qspacebox
    { n = new Fl_Group(130, 25, 110, 75);
      n->tooltip("Normal vector = stands perpendicular on the intersection plane.");
      n->labeltype(FL_NO_LABEL);
      { nre = new Fl_Value_Input(130, 40, 110, 20, "Normal Vector");
        nre->tooltip("Real part.");
        nre->labelsize(12);
        nre->minimum(-1e+20);
        nre->maximum(1e+20);
        nre->textsize(12);
        nre->callback((Fl_Callback*)cb_nre);
        nre->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      } // Fl_Value_Input* nre
      { ni = new Fl_Value_Input(130, 60, 110, 20, "value:");
        ni->tooltip("1st imaginary (i) part.");
        ni->labeltype(FL_NO_LABEL);
        ni->labelsize(12);
        ni->minimum(-1e+20);
        ni->maximum(1e+20);
        ni->textsize(12);
        ni->callback((Fl_Callback*)cb_ni);
      } // Fl_Value_Input* ni
      { nj = new Fl_Value_Input(130, 80, 110, 20, "value:");
        nj->tooltip("2nd imaginary (j) part.");
        nj->labeltype(FL_NO_LABEL);
        nj->labelsize(12);
        nj->minimum(-1e+20);
        nj->maximum(1e+20);
        nj->textsize(12);
        nj->callback((Fl_Callback*)cb_nj);
      } // Fl_Value_Input* nj
      n->end();
    } // Fl_Group* n
    { p = new Fl_Group(270, 25, 110, 75);
      p->tooltip("Any point that lies on the desired plane.");
      p->labeltype(FL_NO_LABEL);
      { pre = new Fl_Value_Input(270, 40, 110, 20, "Point to fix plane");
        pre->tooltip("Real part.");
        pre->labelsize(12);
        pre->minimum(-1e+20);
        pre->maximum(1e+20);
        pre->textsize(12);
        pre->callback((Fl_Callback*)cb_pre);
        pre->align(Fl_Align(FL_ALIGN_TOP_LEFT));
      } // Fl_Value_Input* pre
      { pi = new Fl_Value_Input(270, 60, 110, 20, "value:");
        pi->tooltip("1st imaginary (i) part.");
        pi->labeltype(FL_NO_LABEL);
        pi->labelsize(12);
        pi->minimum(-1e+20);
        pi->maximum(1e+20);
        pi->textsize(12);
        pi->callback((Fl_Callback*)cb_pi);
      } // Fl_Value_Input* pi
      { pj = new Fl_Value_Input(270, 80, 110, 20, "value:");
        pj->tooltip("2nd imaginary (j) part.");
        pj->labeltype(FL_NO_LABEL);
        pj->labelsize(12);
        pj->minimum(-1e+20);
        pj->maximum(1e+20);
        pj->textsize(12);
        pj->callback((Fl_Callback*)cb_pj);
      } // Fl_Value_Input* pj
      p->end();
    } // Fl_Group* p
    { add = new Fl_Button(50, 60, 60, 20, "Add");
      add->tooltip("Add a new intersection plane.");
      add->labelsize(12);
      add->callback((Fl_Callback*)cb_add);
    } // Fl_Button* add
    { del = new Fl_Button(50, 80, 60, 20, "Delete");
      del->tooltip("Delete the current plane.");
      del->labelsize(12);
      del->callback((Fl_Callback*)cb_del);
    } // Fl_Button* del
    { note = new Fl_Box(130, 130, 230, 50, "The Normal Vector points to half-space\nin which the object will disappear.");
      note->labelsize(12);
      note->align(Fl_Align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE));
    } // Fl_Box* note
    { planeno = new Fl_Value_Output(50, 20, 30, 20);
      planeno->labeltype(FL_NO_LABEL);
    } // Fl_Value_Output* planeno
    { Fl_Button* o = new Fl_Button(50, 120, 64, 20, "To View");
      o->tooltip("Aim vector at viewpoint");
      o->callback((Fl_Callback*)cb_To);
    } // Fl_Button* o
    win->clear_border();
    win->end();
  } // ChildWindow* win
  end(); // VERY IMPORTANT!
          win->position(X+2, Y+2);
          // DON'T delete win in destructor (or elsewhere) 
          // it's automatically deleted by Fl_Group
}

void IntersecEditor::set(const CutSpec& cuts, const FractalView& view) {
  _cuts = cuts;
  _view = view;
  _cuts.getPlane(_idx, _curNormal, _curPoint);
  setIndex(0);
  checkValidity();
}

void IntersecEditor::get(CutSpec& cuts) {
  cuts = _cuts;
}

void IntersecEditor::setIndex(size_t idx) {
  if (idx < _cuts.count() || _cuts.count() != 0) {
      _idx = idx;
      _cuts.getPlane(_idx, _curNormal, _curPoint);
      showVectors();
      //checkValidity();
  }
}

void IntersecEditor::showVectors() {
  nre->value(_curNormal[0]);
      ni->value(_curNormal[1]);
      nj->value(_curNormal[2]);
      pre->value(_curPoint[0]);
      pi->value(_curPoint[1]);
      pj->value(_curPoint[2]);
      planeno->value(static_cast<int>(_idx) + 1);
}

void IntersecEditor::deactiv() {
  n->deactivate();
          p->deactivate();
          add->deactivate();
          del->deactivate();
          _disabled = true;
}

void IntersecEditor::checkValidity() {
  constexpr Fl_Color okc = FL_WHITE;
  constexpr Fl_Color ndefc = FL_RED;
  Fl_Color nre_c = okc, ni_c = okc, nj_c = okc;
  
  if (nre->value() == 0.0 && ni->value() == 0.0 && nj->value() == 0.0) {
      nre_c = ndefc; ni_c = ndefc; nj_c = ndefc;
  }
  if (nre->color() != nre_c) { 
      nre->color(nre_c);
      nre->redraw();
  }
  if (ni->color() != ni_c) {
      ni->color(ni_c);
      ni->redraw();
  }
  if (nj->color() != nj_c) {
      nj->color(nj_c); 
      nj->redraw();
  }
  
  if (_cuts.count() == 0 && scroll->active()) {
      qspacebox->hide();
      n->hide(); 
      p->hide();
      note->hide();
      planeno->hide();
      scroll->deactivate();
      del->deactivate();
  }
  if (_cuts.count() != 0 /* && !scroll->active()*/) {
      qspacebox->show();
      n->show(); 
      p->show();
      note->show();
      planeno->show();
      scroll->activate();
  }
  
  if (_cuts.count() == 0 && del->active()) {
      del->deactivate();
  }
  if (_cuts.count() != 0 && !del->active() && !_disabled) {
      del->activate();
  }
  scroll->value(static_cast<int>(_idx + 1), static_cast<int>(_cuts.count()), 1, static_cast<int>(_cuts.count()));
}

void IntersecEditor::setView(const FractalView& view) {
  _view = view;
}
