// generated by Fast Light User Interface Designer (fluid) version 1.0108

#include "IntersecEditor.h"
// Quat - A 3D fractal generation program
// Copyright (C) 1997-2000 Dirk Meyer
// (email: dirk.meyer@studserv.uni-stuttgart.de)
// mail:  Dirk Meyer
//        Marbacher Weg 29
//        D-71334 Waiblingen
//        Germany
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include "ChildWindow.h"

void IntersecEditor::cb_scroll_i(Fl_Scrollbar* o, void*) {
    setno(o->value());
}
void IntersecEditor::cb_scroll(Fl_Scrollbar* o, void* v) {
    ((IntersecEditor*)(o->parent()->user_data()))->cb_scroll_i(o, v);
}

void IntersecEditor::cb_nre_i(Fl_Value_Input* o, void*) {
    _curNormal[0] = o->value();
    _cuts.setPlane(_idx, _curNormal, _curPoint);
    checkValidity();
}
void IntersecEditor::cb_nre(Fl_Value_Input* o, void* v) {
    ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_nre_i(o, v);
}

void IntersecEditor::cb_ni_i(Fl_Value_Input* o, void*) {
    _curNormal[1] = o->value();
    _cuts.setPlane(_idx, _curNormal, _curPoint);
    checkValidity();
}
void IntersecEditor::cb_ni(Fl_Value_Input* o, void* v) {
    ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_ni_i(o, v);
}

void IntersecEditor::cb_nj_i(Fl_Value_Input* o, void*) {
    _curNormal[2] = o->value();
    _cuts.setPlane(_idx, _curNormal, _curPoint);
    checkValidity();
}
void IntersecEditor::cb_nj(Fl_Value_Input* o, void* v) {
    ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_nj_i(o, v);
}

void IntersecEditor::cb_pre_i(Fl_Value_Input* o, void*) {
    _curPoint[0] = o->value();
    _cuts.setPlane(_idx, _curNormal, _curPoint);
}
void IntersecEditor::cb_pre(Fl_Value_Input* o, void* v) {
    ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_pre_i(o, v);
}

void IntersecEditor::cb_pi_i(Fl_Value_Input* o, void*) {
    _curPoint[1] = o->value();
    _cuts.setPlane(_idx, _curNormal, _curPoint);
}
void IntersecEditor::cb_pi(Fl_Value_Input* o, void* v) {
    ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_pi_i(o, v);
}

void IntersecEditor::cb_pj_i(Fl_Value_Input* o, void*) {
    _curPoint[2] = o->value();
    _cuts.setPlane(_idx, _curNormal, _curPoint);
}
void IntersecEditor::cb_pj(Fl_Value_Input* o, void* v) {
    ((IntersecEditor*)(o->parent()->parent()->user_data()))->cb_pj_i(o, v);
}

void IntersecEditor::cb_add_i(Fl_Button*, void*) {
    _cuts.setPlane(_idx, _curNormal, _curPoint);
    _num = _cuts.count();
    scroll->value(static_cast<int>(_num) - 1, 1, 0, static_cast<int>(_num));
    setno(_num - 1);
}
void IntersecEditor::cb_add(Fl_Button* o, void* v) {
    ((IntersecEditor*)(o->parent()->user_data()))->cb_add_i(o, v);
}

void IntersecEditor::cb_del_i(Fl_Button*, void*) {
    _cuts.deletePlane(_idx);
    _num = _cuts.count();
    if (_idx >= _num && _idx != 0) _idx = _num - 1;
    scroll->value(static_cast<int>(_idx), 1, 0, static_cast<int>(_num));
    setno(_idx);
}
void IntersecEditor::cb_del(Fl_Button* o, void* v) {
    ((IntersecEditor*)(o->parent()->user_data()))->cb_del_i(o, v);
}

void IntersecEditor::cb_To_i(Fl_Button* o, void*) {
    //double x = o->value();
    //_curPoint = vec3(x, x, x);
    _curNormal = (_view->_s - _curPoint).normalize();
    showVectors();
    _cuts.setPlane(_idx, _curNormal, _curPoint);
    checkValidity();
}
void IntersecEditor::cb_To(Fl_Button* o, void* v) {
    ((IntersecEditor*)(o->parent()->user_data()))->cb_To_i(o, v);
}

IntersecEditor::IntersecEditor(int X, int Y, int W, int H, const char* label) : Fl_Group(X, Y, W, H, label), _num(0), _idx(0), _disabled(false) {
    { win = new ChildWindow(416, 216);
    win->box(FL_FLAT_BOX);
    win->color(FL_BACKGROUND_COLOR);
    win->selection_color(FL_BACKGROUND_COLOR);
    win->labeltype(FL_NO_LABEL);
    win->labelfont(0);
    win->labelsize(14);
    win->labelcolor(FL_FOREGROUND_COLOR);
    win->user_data((void*)(this));
    win->align(FL_ALIGN_TOP);
    win->when(FL_WHEN_RELEASE);
    { scroll = new Fl_Scrollbar(10, 20, 20, 150, "Plane to edit");
    scroll->tooltip("Select the intersection plane to edit.");
    scroll->labelsize(12);
    scroll->callback((Fl_Callback*)cb_scroll);
    scroll->align(FL_ALIGN_TOP_LEFT);
    scroll->linesize(1); scroll->value(0, 1, 0, 0);
    } // Fl_Scrollbar* scroll
    { qspacebox = new Fl_Group(120, 5, 270, 115, "QSpace coordinates");
    qspacebox->tooltip("All parameters in this box are measured in QSpace coordinates.");
    qspacebox->box(FL_EMBOSSED_BOX);
    qspacebox->labelsize(12);
    qspacebox->align(FL_ALIGN_TOP_LEFT | FL_ALIGN_INSIDE);
    qspacebox->end();
    } // Fl_Group* qspacebox
    { n = new Fl_Group(130, 25, 110, 75);
    n->tooltip("Normal vector = stands perpendicular on the intersection plane.");
    n->labeltype(FL_NO_LABEL);
    { nre = new Fl_Value_Input(130, 40, 110, 20, "Normal Vector");
    nre->tooltip("Real part.");
    nre->labelsize(12);
    nre->minimum(-1e+20);
    nre->maximum(1e+20);
    nre->textsize(12);
    nre->callback((Fl_Callback*)cb_nre);
    nre->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Input* nre
    { ni = new Fl_Value_Input(130, 60, 110, 20, "value:");
    ni->tooltip("1st imaginary (i) part.");
    ni->labeltype(FL_NO_LABEL);
    ni->labelsize(12);
    ni->minimum(-1e+20);
    ni->maximum(1e+20);
    ni->textsize(12);
    ni->callback((Fl_Callback*)cb_ni);
    } // Fl_Value_Input* ni
    { nj = new Fl_Value_Input(130, 80, 110, 20, "value:");
    nj->tooltip("2nd imaginary (j) part.");
    nj->labeltype(FL_NO_LABEL);
    nj->labelsize(12);
    nj->minimum(-1e+20);
    nj->maximum(1e+20);
    nj->textsize(12);
    nj->callback((Fl_Callback*)cb_nj);
    } // Fl_Value_Input* nj
    n->end();
    } // Fl_Group* n
    { p = new Fl_Group(270, 25, 110, 75);
    p->tooltip("Any point that lies on the desired plane.");
    p->labeltype(FL_NO_LABEL);
    { pre = new Fl_Value_Input(270, 40, 110, 20, "Point to fix plane");
    pre->tooltip("Real part.");
    pre->labelsize(12);
    pre->minimum(-1e+20);
    pre->maximum(1e+20);
    pre->textsize(12);
    pre->callback((Fl_Callback*)cb_pre);
    pre->align(FL_ALIGN_TOP_LEFT);
    } // Fl_Value_Input* pre
    { pi = new Fl_Value_Input(270, 60, 110, 20, "value:");
    pi->tooltip("1st imaginary (i) part.");
    pi->labeltype(FL_NO_LABEL);
    pi->labelsize(12);
    pi->minimum(-1e+20);
    pi->maximum(1e+20);
    pi->textsize(12);
    pi->callback((Fl_Callback*)cb_pi);
    } // Fl_Value_Input* pi
    { pj = new Fl_Value_Input(270, 80, 110, 20, "value:");
    pj->tooltip("2nd imaginary (j) part.");
    pj->labeltype(FL_NO_LABEL);
    pj->labelsize(12);
    pj->minimum(-1e+20);
    pj->maximum(1e+20);
    pj->textsize(12);
    pj->callback((Fl_Callback*)cb_pj);
    } // Fl_Value_Input* pj
    p->end();
    } // Fl_Group* p
    { add = new Fl_Button(50, 60, 60, 20, "Add");
    add->tooltip("Add a new intersection plane.");
    add->labelsize(12);
    add->callback((Fl_Callback*)cb_add);
    } // Fl_Button* add
    { del = new Fl_Button(50, 80, 60, 20, "Delete");
    del->tooltip("Delete the current plane.");
    del->labelsize(12);
    del->callback((Fl_Callback*)cb_del);
    } // Fl_Button* del
    { note = new Fl_Box(130, 130, 230, 50, "The Normal Vector points to half-space\nin which the object will disappear.");
    note->labelsize(12);
    note->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
    } // Fl_Box* note
    { planeno = new Fl_Value_Output(50, 20, 30, 20);
    planeno->labeltype(FL_NO_LABEL);
    } // Fl_Value_Output* planeno
    { Fl_Button* o = new Fl_Button(50, 120, 64, 20, "To View");
    o->tooltip("Aim vector at viewpoint");
    o->callback((Fl_Callback*)cb_To);
    } // Fl_Button* o
    win->clear_border();
    win->end();
    } // ChildWindow* win
    end(); // VERY IMPORTANT!
    win->position(X + 2, Y + 2);
    // DON'T delete win in destructor (or elsewhere) 
    // it's automatically deleted by Fl_Group
}

void IntersecEditor::setCuts(const CutSpec& cuts) {
    _cuts = cuts;
    _num = _cuts.count();
    _idx = 0;
    cuts.getPlane(_idx, _curNormal, _curPoint);
    scroll->value(0, 1, 0, static_cast<int>(_num));
    setno(0);
    checkValidity();
}

void IntersecEditor::setView(FractalView* view) {
    _view = view;
}

void IntersecEditor::get(CutSpec& buf) {
    buf = _cuts;
}

void IntersecEditor::setno(size_t no) {
    if (no < _num || _num == 0) {
        _cuts.getPlane(no, _curNormal, _curPoint);
        _idx = no;
        showVectors();
        checkValidity();
    }
}

void IntersecEditor::checkValidity() {
    const Fl_Color okc = FL_WHITE;
    const Fl_Color ndefc = FL_RED;
    Fl_Color nre_c = okc, ni_c = okc, nj_c = okc;

    if (nre->value() == 0.0 && ni->value() == 0.0 && nj->value() == 0.0) {
        nre_c = ndefc; ni_c = ndefc; nj_c = ndefc;
    }

    if (nre->color() != nre_c) { nre->color(nre_c); nre->redraw(); }
    if (ni->color() != ni_c) { ni->color(ni_c); ni->redraw(); }
    if (nj->color() != nj_c) { nj->color(nj_c); nj->redraw(); }

    if (_num == 0 && scroll->active()) {
        qspacebox->hide();
        n->hide();
        p->hide();
        note->hide();
        planeno->hide();
        scroll->deactivate(); del->deactivate();
    }
    if (_num != 0 && !scroll->active()) {
        qspacebox->show();
        n->show();
        p->show();
        note->show();
        planeno->show();
        scroll->activate();
    }
    if (_num == 20 && add->active()) add->deactivate();
    if (_num != 20 && !add->active() && !_disabled) add->activate();

    if (_num == 0 && del->active()) del->deactivate();
    if (_num != 0 && !del->active() && !_disabled) del->activate();

    return;
}

void IntersecEditor::deactiv() {
    n->deactivate();
    p->deactivate();
    add->deactivate();
    del->deactivate();
    _disabled = true;
}


void IntersecEditor::showVectors() {
    nre->value(_curNormal[0]);
    ni->value(_curNormal[1]);
    nj->value(_curNormal[2]);
    pre->value(_curPoint[0]);
    pi->value(_curPoint[1]);
    pj->value(_curPoint[2]);
    planeno->value(static_cast<int>(_idx) + 1);
}